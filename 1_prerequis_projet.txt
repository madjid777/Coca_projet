ğŸ¯ BUT : Faire une rÃ©duction polynomiale TUNNEL -> SAT 

= Construire une formule logique Ï† telle que :

	- Ï† est satisfiable ssi il existe un chemin valide dans le graph

Autrement dit :

Un chemin valide existe ssi le solveur Z3 trouve un modÃ¨le qui satisfait Ï†

NB - Z3 = Solver = vÃ©rifie si Ï† est satisfiable (SAT), Nous n'avons pas besoin de dÃ©velopper le Solver Z3, car il est dÃ©jÃ  fourni comme bibliothÃ¨que, et nous y accÃ©dons via son API.

Voici les principales fonctions Z3 qu'on utilisera pour construire la formule Ï† :

- Z3_mk_and
- Z3_mk_or
- Z3_mk_not
- Z3_mk_implies
- Z3_mk_eq
- Z3_mk_true / false
- Z3_mk_context
- Z3_mk_solver 




ğŸ§© DÃ©finition du problÃ¨me : 

On cherche Ã  savoir sâ€™il existe un chemin simple de longueur ğ‘™ allant dâ€™un nÅ“ud de dÃ©part ğ‘  Ã  un nÅ“ud dâ€™arrivÃ©e ğ‘‘.

Un chemin simple signifie :

- Aucun cycle
- Aucun nÅ“ud nâ€™est visitÃ© plus dâ€™une fois


âš ï¸ Contraintes Ã  respecter

- Pas de cycles
- Pas de rÃ©pÃ©tition de nÅ“uds
- Pas de retour en arriÃ¨re
- Chaque nÅ“ud apparaÃ®t au plus une fois dans tout le chemin


ğŸ§  Ã€ savoir

- Inutile de dÃ©montrer que TUNNEL est NP-complet (câ€™est un aspect thÃ©orique, pas Ã  implÃ©menter).
- Z3 : vÃ©rifie si la formule Ï† est satisfiable.
- tn_reduction : construit la formule Ï†.
- tn_get_path_from_model : reconstruit le chemin valide Ã  partir du modÃ¨le trouvÃ© par Z3.


âš™ï¸ Ã‰tapes de la rÃ©duction polynomiale (TUNNEL â†’ SAT)

1. DÃ©finir les variables boolÃ©ennes
2. Ajouter les conditions initiales et finales
3. Imposer les contraintes dâ€™unicitÃ©
4. DÃ©finir les contraintes de transition
	- liÃ©es au graphe
	- liÃ©es Ã  la pile


ğŸ’» Ordre optimal de codage dans tn_reduction

1. Conditions initiales (facile)
2. Conditions finales (facile)
3. UnicitÃ©
4. Simple path (pas de rÃ©pÃ©tition de nÅ“uds)
5. ArÃªtes (transitions possibles dans le graphe)
6. Transmission (propagation des Ã©tats ou de la pile)
7. PUSH (ajout dans la pile)
8. POP (retrait de la pile)





// *********** Fichiers nÃ©cessaires pour la rÃ©duction du problÃ¨me TUNNEL vers SAT *********** //

Voici le Graph (graphs > TunnelNetwork > exemple1.dot) qui va nous permettre de vÃ©rifier que la rÃ©duction SAT trouve exactement un seul chemin valide :

digraph A {
    s  [label="4â†’4"]      // Transmission IPv4
    u1 [label="4â†‘46"]     // PUSH : 4 encap â†’ 6
    u2 [label="4â†’4"]      // Transmission IPv4
    u3 [label="6â†’6"]      // Transmission IPv6
    d  [label="46â†“4"]     // POP : (6â†’4)
    end [label="4â†’4"]     // Transmission IPv4 (nÅ“ud terminal)

    s -> u1
    u1 -> u2
    u1 -> u3
    u2 -> d
    u3 -> d
    d  -> end
}


ğŸ‘‰ s â†’ u1 â†’ u3 â†’ d â†’ end

car câ€™est le seul qui respecte correctement la pile [4] â†’ [6,4] â†’ [6,4] â†’ [4] â†’ [4].





ğŸ‘‰ Dans notre fichier principal TunnelReduction.c, on fera appel Ã  des fonctions qui se trouvent dans le fichier TunnelNetwork.c pour interroger le graphe Tunnel (nÅ“uds, arÃªtes, actions) et ainsi construire correctement les contraintes de la formule SAT.

Voici les fonctions dans TunnelNetwork.c que nous utiliserons :

- tn_get_num_nodes() : savoir combien il y a de nÅ“uds = boucler correctement sur toutes les positions
- tn_is_edge() : savoir si une arÃªte existe = Ã©crire les contraintes de transition (graphe)
- tn_node_has_action() : savoir si un nÅ“ud peut PUSH/POP/T = Ã©crire les contraintes de transition (pile)
- tn_get_initial(), tn_get_final() : connaÃ®tre s et d = conditions initiales/finales
- tn_get_node_name() : connaÃ®tre les noms (debug) = affichage, tests

ğŸ‘‰ Câ€™est grÃ¢ce Ã  TunnelNetwork.c que ta rÃ©duction sait :

- quels nÅ“uds existent
- quelles arÃªtes existent
- quelles actions sont possibles
- oÃ¹ commence et oÃ¹ finit le chemin
- comment chaque nÅ“ud se comporte (T/PUSH/POP)
